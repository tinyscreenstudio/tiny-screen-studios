import { describe, it, expect } from 'vitest';
import {
  toCRawArray,
  makeCArrayFiles,
  validateCExportOptions,
} from './c-array.js';
import type { PackedFrame } from '../types/index.js';

// Test helper to create a packed frame
function createTestFrame(
  width: number,
  height: number,
  bytes: number[],
  preset:
    | 'SSD1306_128x32'
    | 'SSD1306_128x64'
    | 'SH1106_132x64' = 'SSD1306_128x32',
  delayMs?: number
): PackedFrame {
  return {
    bytes: new Uint8Array(bytes),
    dims: { width, height },
    preset,
    delayMs,
  };
}

describe('C Array Exporter', () => {
  describe('toCRawArray', () => {
    it('should generate basic C array for single frame', () => {
      const frame = createTestFrame(8, 8, [0x01, 0x02, 0x03, 0x04]);
      const result = toCRawArray([frame], 'test_data');

      expect(result).toContain('const uint8_t test_data[4] = {');
      expect(result).toContain('0x01, 0x02, 0x03, 0x04');
      expect(result).toContain('Generated by Tiny Screen Studios');
      expect(result).toContain('Symbol: test_data');
      expect(result).toContain('Device: SSD1306_128x32');
      expect(result).toContain('Dimensions: 8x8');
      expect(result).toContain('Frames: 1');
    });

    it('should sanitize invalid symbol names', () => {
      const frame = createTestFrame(8, 8, [0x01]);
      const result = toCRawArray([frame], '123-invalid name!');

      expect(result).toContain('const uint8_t _123_invalid_name_[1] = {');
    });

    it('should handle empty symbol name', () => {
      const frame = createTestFrame(8, 8, [0x01]);
      const result = toCRawArray([frame], '');

      expect(result).toContain('const uint8_t display_data[1] = {');
    });

    it('should format bytes with configurable bytes per row', () => {
      const frame = createTestFrame(8, 8, [0x01, 0x02, 0x03, 0x04, 0x05, 0x06]);
      const result = toCRawArray([frame], 'test', {
        bytesPerRow: 3,
        autoLineWrap: false,
      });

      const lines = result.split('\n');
      const dataLines = lines.filter(line => line.includes('0x'));

      // Should have 2 data lines (6 bytes / 3 per row)
      expect(dataLines).toHaveLength(2);
      expect(dataLines[0]).toContain('0x01, 0x02, 0x03');
      expect(dataLines[1]).toContain('0x04, 0x05, 0x06');
    });

    it('should generate per-frame arrays when perFrame is true', () => {
      const frames = [
        createTestFrame(8, 8, [0x01, 0x02], 'SSD1306_128x32'),
        createTestFrame(8, 8, [0x03, 0x04], 'SSD1306_128x32'),
      ];
      const result = toCRawArray(frames, 'animation', { perFrame: true });

      expect(result).toContain('const uint8_t animation_frame_0[2] = {');
      expect(result).toContain('const uint8_t animation_frame_1[2] = {');
      expect(result).toContain('const uint8_t* const animation_frames[2] = {');
      expect(result).toContain('const uint16_t animation_sizes[2] = {');
      expect(result).toContain('animation_frame_0');
      expect(result).toContain('animation_frame_1');
    });

    it('should generate concatenated array when perFrame is false', () => {
      const frames = [
        createTestFrame(8, 8, [0x01, 0x02], 'SSD1306_128x32'),
        createTestFrame(8, 8, [0x03, 0x04], 'SSD1306_128x32'),
      ];
      const result = toCRawArray(frames, 'animation', { perFrame: false });

      expect(result).toContain('const uint8_t animation[4] = {');
      expect(result).toContain('0x01, 0x02, 0x03, 0x04');
      expect(result).toContain('const uint16_t animation_offsets[2] = {');
      expect(result).toContain('const uint16_t animation_sizes[2] = {');
      expect(result).toContain('0, // Frame 0');
      expect(result).toContain('2 // Frame 1');
    });

    it('should include timing data when frames have delays', () => {
      const frames = [
        createTestFrame(8, 8, [0x01], 'SSD1306_128x32', 100),
        createTestFrame(8, 8, [0x02], 'SSD1306_128x32', 200),
      ];
      const result = toCRawArray(frames, 'timed', { perFrame: true });

      expect(result).toContain('const uint16_t timed_delays[2] = {');
      expect(result).toContain('100');
      expect(result).toContain('200');
      expect(result).toContain('Delay: 100ms');
      expect(result).toContain('Delay: 200ms');
    });

    it('should handle frames without timing data', () => {
      const frames = [
        createTestFrame(8, 8, [0x01], 'SSD1306_128x32'),
        createTestFrame(8, 8, [0x02], 'SSD1306_128x32', 150),
      ];
      const result = toCRawArray(frames, 'mixed', { perFrame: true });

      expect(result).toContain('const uint16_t mixed_delays[2] = {');
      expect(result).toContain('100'); // Default delay for frame without delayMs
      expect(result).toContain('150'); // Explicit delay
    });

    it('should disable metadata when includeMetadata is false', () => {
      const frame = createTestFrame(8, 8, [0x01]);
      const result = toCRawArray([frame], 'test', { includeMetadata: false });

      expect(result).not.toContain('Generated by Tiny Screen Studios');
      expect(result).not.toContain('Symbol:');
      expect(result).not.toContain('Device:');
      expect(result).toContain('const uint8_t test[1] = {');
    });

    it('should throw error for empty frames array', () => {
      expect(() => toCRawArray([], 'test')).toThrow('No frames provided');
    });

    it('should throw error for invalid bytesPerRow', () => {
      const frame = createTestFrame(8, 8, [0x01]);
      expect(() =>
        toCRawArray([frame], 'test', { bytesPerRow: 0, autoLineWrap: false })
      ).toThrow('bytesPerRow must be between 1 and 256');
      expect(() =>
        toCRawArray([frame], 'test', { bytesPerRow: 257, autoLineWrap: false })
      ).toThrow('bytesPerRow must be between 1 and 256');
    });

    it('should handle different device presets', () => {
      const frame128x64 = createTestFrame(
        128,
        64,
        [0x01, 0x02],
        'SSD1306_128x64'
      );
      const frameSH1106 = createTestFrame(
        132,
        64,
        [0x03, 0x04],
        'SH1106_132x64'
      );

      const result128x64 = toCRawArray([frame128x64], 'oled64');
      const resultSH1106 = toCRawArray([frameSH1106], 'sh1106');

      expect(result128x64).toContain('Device: SSD1306_128x64');
      expect(result128x64).toContain('Dimensions: 128x64');
      expect(resultSH1106).toContain('Device: SH1106_132x64');
      expect(resultSH1106).toContain('Dimensions: 132x64');
    });

    it('should format large byte arrays correctly', () => {
      // Create a frame with 32 bytes to test line wrapping
      const bytes = Array.from({ length: 32 }, (_, i) => i);
      const frame = createTestFrame(32, 8, bytes);
      const result = toCRawArray([frame], 'large', {
        bytesPerRow: 8,
        autoLineWrap: false,
      });

      const lines = result.split('\n');
      const dataLines = lines.filter(line => line.includes('0x'));

      // Should have 4 data lines (32 bytes / 8 per row)
      expect(dataLines).toHaveLength(4);
      expect(dataLines[0]).toContain(
        '0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07'
      );
      expect(dataLines[3]).toContain(
        '0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F'
      );
    });
  });

  describe('makeCArrayFiles', () => {
    it('should generate both .c and .h files', () => {
      const frame = createTestFrame(8, 8, [0x01, 0x02]);
      const files = makeCArrayFiles([frame], 'display_data');

      expect(files).toHaveLength(2);

      const cFile = files.find(f => f.name.endsWith('.c'));
      const hFile = files.find(f => f.name.endsWith('.h'));

      expect(cFile).toBeDefined();
      expect(hFile).toBeDefined();
      expect(cFile!.name).toBe('display_data.c');
      expect(hFile!.name).toBe('display_data.h');
      expect(cFile!.mimeType).toBe('text/plain');
      expect(hFile!.mimeType).toBe('text/plain');
    });

    it('should generate proper header file content', () => {
      const frames = [
        createTestFrame(128, 32, [0x01, 0x02], 'SSD1306_128x32'),
        createTestFrame(128, 32, [0x03, 0x04], 'SSD1306_128x32'),
      ];
      const files = makeCArrayFiles(frames, 'animation', { perFrame: true });

      const hFile = files.find(f => f.name.endsWith('.h'));
      const headerContent = new TextDecoder().decode(hFile!.data);

      expect(headerContent).toContain('#ifndef ANIMATION_H');
      expect(headerContent).toContain('#define ANIMATION_H');
      expect(headerContent).toContain('#include <stdint.h>');
      expect(headerContent).toContain(
        'extern const uint8_t animation_frame_0[2];'
      );
      expect(headerContent).toContain(
        'extern const uint8_t animation_frame_1[2];'
      );
      expect(headerContent).toContain(
        'extern const uint8_t* const animation_frames[2];'
      );
      expect(headerContent).toContain('#define ANIMATION_WIDTH 128');
      expect(headerContent).toContain('#define ANIMATION_HEIGHT 32');
      expect(headerContent).toContain('#define ANIMATION_FRAMES 2');
      expect(headerContent).toContain('#define ANIMATION_IS_ANIMATION 1');
      expect(headerContent).toContain('#endif // ANIMATION_H');
    });

    it('should generate header for single frame', () => {
      const frame = createTestFrame(64, 32, [0x01, 0x02], 'SSD1306_128x32');
      const files = makeCArrayFiles([frame], 'single');

      const hFile = files.find(f => f.name.endsWith('.h'));
      const headerContent = new TextDecoder().decode(hFile!.data);

      expect(headerContent).toContain('extern const uint8_t single[2];');
      expect(headerContent).toContain('#define SINGLE_IS_ANIMATION 0');
      expect(headerContent).not.toContain('_frames');
      expect(headerContent).not.toContain('_offsets');
    });

    it('should generate header for batch mode', () => {
      const frames = [
        createTestFrame(8, 8, [0x01, 0x02], 'SSD1306_128x32'),
        createTestFrame(8, 8, [0x03, 0x04], 'SSD1306_128x32'),
      ];
      const files = makeCArrayFiles(frames, 'batch', { perFrame: false });

      const hFile = files.find(f => f.name.endsWith('.h'));
      const headerContent = new TextDecoder().decode(hFile!.data);

      expect(headerContent).toContain('extern const uint8_t batch[4];');
      expect(headerContent).toContain(
        'extern const uint16_t batch_offsets[2];'
      );
      expect(headerContent).toContain('extern const uint16_t batch_sizes[2];');
    });
  });

  describe('validateCExportOptions', () => {
    it('should validate valid options', () => {
      expect(validateCExportOptions({})).toBe(true);
      expect(validateCExportOptions({ bytesPerRow: 16 })).toBe(true);
      expect(validateCExportOptions({ perFrame: true })).toBe(true);
      expect(validateCExportOptions({ includeMetadata: false })).toBe(true);
    });

    it('should reject invalid bytesPerRow', () => {
      expect(validateCExportOptions({ bytesPerRow: 0 })).toBe(false);
      expect(validateCExportOptions({ bytesPerRow: -1 })).toBe(false);
      expect(validateCExportOptions({ bytesPerRow: 257 })).toBe(false);
    });

    it('should accept valid bytesPerRow range', () => {
      expect(validateCExportOptions({ bytesPerRow: 1 })).toBe(true);
      expect(validateCExportOptions({ bytesPerRow: 16 })).toBe(true);
      expect(validateCExportOptions({ bytesPerRow: 32 })).toBe(true);
    });
  });

  describe('Symbol name sanitization', () => {
    it('should handle various invalid characters', () => {
      const testCases = [
        { input: 'my-display', expected: 'my_display' },
        { input: 'display.data', expected: 'display_data' },
        { input: '123data', expected: '_123data' },
        { input: 'my display!', expected: 'my_display_' },
        { input: 'åéîøü', expected: '_____' },
        { input: '', expected: 'display_data' },
        { input: '_', expected: 'display_data' },
      ];

      testCases.forEach(({ input, expected }) => {
        const frame = createTestFrame(8, 8, [0x01]);
        const result = toCRawArray([frame], input);
        expect(result).toContain(`const uint8_t ${expected}[1] = {`);
      });
    });
  });

  describe('Real-world scenarios', () => {
    it('should generate code for SSD1306 128x32 display', () => {
      // Simulate a 128x32 display (4 pages * 128 columns = 512 bytes)
      const bytes = new Array(512).fill(0).map((_, i) => i % 256);
      const frame = createTestFrame(128, 32, bytes, 'SSD1306_128x32');
      const result = toCRawArray([frame], 'ssd1306_logo');

      expect(result).toContain('const uint8_t ssd1306_logo[512] = {');
      expect(result).toContain('Device: SSD1306_128x32');
      expect(result).toContain('Dimensions: 128x32');
      expect(result).toContain('Total bytes: 512');
    });

    it('should generate code for animated sequence', () => {
      // Simulate a 3-frame animation
      const frames = [
        createTestFrame(64, 32, [0x00, 0x01], 'SSD1306_128x32', 100),
        createTestFrame(64, 32, [0x02, 0x03], 'SSD1306_128x32', 150),
        createTestFrame(64, 32, [0x04, 0x05], 'SSD1306_128x32', 100),
      ];
      const result = toCRawArray(frames, 'spinner_anim', {
        perFrame: true,
        bytesPerRow: 8,
      });

      expect(result).toContain('Animation: Yes (with timing data)');
      expect(result).toContain('const uint8_t spinner_anim_frame_0[2] = {');
      expect(result).toContain('const uint8_t spinner_anim_frame_1[2] = {');
      expect(result).toContain('const uint8_t spinner_anim_frame_2[2] = {');
      expect(result).toContain(
        'const uint8_t* const spinner_anim_frames[3] = {'
      );
      expect(result).toContain('const uint16_t spinner_anim_delays[3] = {');
      expect(result).toContain('100,');
      expect(result).toContain('150,');
    });

    it('should generate minimal code without metadata', () => {
      const frame = createTestFrame(8, 8, [0xff, 0x00, 0xaa, 0x55]);
      const result = toCRawArray([frame], 'minimal', {
        includeMetadata: false,
        bytesPerRow: 4,
      });

      // Should only contain the essential C code
      expect(result).not.toContain('/*');
      expect(result).not.toContain('//');
      expect(result).toContain('const uint8_t minimal[4] = {');
      expect(result).toContain('0xFF, 0x00, 0xAA, 0x55');

      // Should be relatively short
      const lines = result.split('\n').filter(line => line.trim() !== '');
      expect(lines.length).toBeLessThan(5);
    });
  });
});
