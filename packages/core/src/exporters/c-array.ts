import type {
  PackedFrame,
  CExportOptions,
  ExportFile,
} from '../types/index.js';

/**
 * C array exporter for embedded firmware development
 * Generates properly formatted C code with configurable options
 */

/**
 * Convert packed frames to C array format
 * @param frames Array of packed frames to export
 * @param symbolName Base symbol name for the C arrays
 * @param options Export configuration options
 * @returns Formatted C code as string
 */
export function toCRawArray(
  frames: PackedFrame[],
  symbolName: string,
  options: CExportOptions = {}
): string {
  if (!frames || frames.length === 0) {
    throw new Error('No frames provided for C array export');
  }

  // Validate and sanitize symbol name
  const sanitizedSymbol = sanitizeSymbolName(symbolName || '');

  // Set default options
  const opts: Required<CExportOptions> = {
    perFrame: options.perFrame ?? false,
    bytesPerRow: options.bytesPerRow ?? 16,
    includeMetadata: options.includeMetadata ?? true,
  };

  // Validate options
  if (opts.bytesPerRow < 1 || opts.bytesPerRow > 32) {
    throw new Error('bytesPerRow must be between 1 and 32');
  }

  let output = '';

  // Add file header with metadata
  if (opts.includeMetadata) {
    output += generateFileHeader(frames, sanitizedSymbol);
  }

  if (opts.perFrame) {
    // Generate separate array for each frame
    output += generatePerFrameArrays(frames, sanitizedSymbol, opts);
  } else {
    // Generate single concatenated array
    output += generateBatchArray(frames, sanitizedSymbol, opts);
  }

  return output;
}

/**
 * Generate C array export files
 * @param frames Array of packed frames to export
 * @param symbolName Base symbol name for the C arrays
 * @param options Export configuration options
 * @returns Array of export files (.h and .c files)
 */
export function makeCArrayFiles(
  frames: PackedFrame[],
  symbolName: string,
  options: CExportOptions = {}
): ExportFile[] {
  const cCode = toCRawArray(frames, symbolName, options);
  const sanitizedSymbol = sanitizeSymbolName(symbolName);

  const headerFile = generateHeaderFile(frames, sanitizedSymbol, options);

  const files: ExportFile[] = [
    {
      name: `${sanitizedSymbol}.c`,
      data: new TextEncoder().encode(cCode),
      mimeType: 'text/plain',
    },
    {
      name: `${sanitizedSymbol}.h`,
      data: new TextEncoder().encode(headerFile),
      mimeType: 'text/plain',
    },
  ];

  return files;
}

/**
 * Sanitize symbol name for C compatibility
 * @param symbolName Raw symbol name
 * @returns Valid C identifier
 */
function sanitizeSymbolName(symbolName: string): string {
  // Remove invalid characters and ensure it starts with letter or underscore
  let sanitized = symbolName
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/^[0-9]/, '_$&'); // Prefix numbers with underscore

  // Ensure it's not empty
  if (sanitized === '' || sanitized === '_') {
    sanitized = 'display_data';
  }

  return sanitized;
}

/**
 * Generate file header with metadata comments
 * @param frames Array of frames
 * @param symbolName Sanitized symbol name
 * @returns Header comment string
 */
function generateFileHeader(frames: PackedFrame[], symbolName: string): string {
  const firstFrame = frames[0]!; // Safe because we validate frames.length > 0 earlier
  const totalBytes = frames.reduce((sum, frame) => sum + frame.bytes.length, 0);

  let header = `/*\n`;
  header += ` * Generated by Tiny Screen Studios\n`;
  header += ` * Symbol: ${symbolName}\n`;
  header += ` * Device: ${firstFrame.preset}\n`;
  header += ` * Dimensions: ${firstFrame.dims.width}x${firstFrame.dims.height}\n`;
  header += ` * Frames: ${frames.length}\n`;
  header += ` * Total bytes: ${totalBytes}\n`;

  if (frames.length > 1) {
    const hasDelays = frames.some(f => f.delayMs !== undefined);
    if (hasDelays) {
      header += ` * Animation: Yes (with timing data)\n`;
    } else {
      header += ` * Animation: Yes (no timing data)\n`;
    }
  }

  header += ` * Generated: ${new Date().toISOString()}\n`;
  header += ` */\n\n`;

  return header;
}

/**
 * Generate separate arrays for each frame
 * @param frames Array of frames
 * @param symbolName Sanitized symbol name
 * @param options Export options
 * @returns C code string
 */
function generatePerFrameArrays(
  frames: PackedFrame[],
  symbolName: string,
  options: Required<CExportOptions>
): string {
  let output = '';

  // Generate individual frame arrays
  for (let i = 0; i < frames.length; i++) {
    const frame = frames[i]!; // Safe because we're iterating within bounds
    const frameSymbol =
      frames.length === 1 ? symbolName : `${symbolName}_frame_${i}`;

    if (options.includeMetadata) {
      output += `// Frame ${i}: ${frame.dims.width}x${frame.dims.height}, ${frame.bytes.length} bytes\n`;
      if (frame.delayMs !== undefined) {
        output += `// Delay: ${frame.delayMs}ms\n`;
      }
    }

    output += `const uint8_t ${frameSymbol}[${frame.bytes.length}] = {\n`;
    output += formatByteArray(frame.bytes, options.bytesPerRow);
    output += `};\n\n`;
  }

  // Generate frame pointer array if multiple frames
  if (frames.length > 1) {
    if (options.includeMetadata) {
      output += `// Array of frame pointers\n`;
    }
    output += `const uint8_t* const ${symbolName}_frames[${frames.length}] = {\n`;
    for (let i = 0; i < frames.length; i++) {
      const frameSymbol = `${symbolName}_frame_${i}`;
      output += `    ${frameSymbol}`;
      if (i < frames.length - 1) output += ',';
      output += '\n';
    }
    output += `};\n\n`;

    // Generate frame sizes array
    if (options.includeMetadata) {
      output += `// Frame sizes in bytes\n`;
    }
    output += `const uint16_t ${symbolName}_sizes[${frames.length}] = {\n`;
    for (let i = 0; i < frames.length; i++) {
      output += `    ${frames[i]!.bytes.length}`;
      if (i < frames.length - 1) output += ',';
      output += '\n';
    }
    output += `};\n\n`;

    // Generate timing array if delays are present
    const hasDelays = frames.some(f => f.delayMs !== undefined);
    if (hasDelays) {
      if (options.includeMetadata) {
        output += `// Frame delays in milliseconds\n`;
      }
      output += `const uint16_t ${symbolName}_delays[${frames.length}] = {\n`;
      for (let i = 0; i < frames.length; i++) {
        const delay = frames[i]!.delayMs ?? 100; // Default 100ms
        output += `    ${delay}`;
        if (i < frames.length - 1) output += ',';
        output += '\n';
      }
      output += `};\n\n`;
    }
  }

  return output;
}

/**
 * Generate single concatenated array
 * @param frames Array of frames
 * @param symbolName Sanitized symbol name
 * @param options Export options
 * @returns C code string
 */
function generateBatchArray(
  frames: PackedFrame[],
  symbolName: string,
  options: Required<CExportOptions>
): string {
  // Calculate total size and concatenate all frame data
  const totalSize = frames.reduce((sum, frame) => sum + frame.bytes.length, 0);
  const concatenatedData = new Uint8Array(totalSize);

  let offset = 0;
  for (const frame of frames) {
    concatenatedData.set(frame.bytes, offset);
    offset += frame.bytes.length;
  }

  let output = '';

  if (options.includeMetadata) {
    output += `// Concatenated frame data: ${frames.length} frame(s), ${totalSize} bytes total\n`;
  }

  output += `const uint8_t ${symbolName}[${totalSize}] = {\n`;
  output += formatByteArray(concatenatedData, options.bytesPerRow);
  output += `};\n\n`;

  // Add frame offset information for multi-frame data
  if (frames.length > 1) {
    if (options.includeMetadata) {
      output += `// Frame offsets within the concatenated array\n`;
    }
    output += `const uint16_t ${symbolName}_offsets[${frames.length}] = {\n`;

    offset = 0;
    for (let i = 0; i < frames.length; i++) {
      output += `    ${offset}`;
      if (i < frames.length - 1) output += ',';
      output += ` // Frame ${i}\n`;
      offset += frames[i]!.bytes.length;
    }
    output += `};\n\n`;

    // Add frame sizes
    if (options.includeMetadata) {
      output += `// Frame sizes in bytes\n`;
    }
    output += `const uint16_t ${symbolName}_sizes[${frames.length}] = {\n`;
    for (let i = 0; i < frames.length; i++) {
      output += `    ${frames[i]!.bytes.length}`;
      if (i < frames.length - 1) output += ',';
      output += '\n';
    }
    output += `};\n\n`;
  }

  return output;
}

/**
 * Format byte array with proper indentation and line breaks
 * @param bytes Byte array to format
 * @param bytesPerRow Number of bytes per row
 * @returns Formatted string
 */
function formatByteArray(bytes: Uint8Array, bytesPerRow: number): string {
  let output = '';

  for (let i = 0; i < bytes.length; i++) {
    if (i % bytesPerRow === 0) {
      output += '    '; // Indentation
    }

    // Format byte as hex with 0x prefix
    output += `0x${bytes[i]!.toString(16).padStart(2, '0').toUpperCase()}`;

    // Add comma if not the last byte
    if (i < bytes.length - 1) {
      output += ',';
    }

    // Add space between bytes on same line
    if ((i + 1) % bytesPerRow !== 0 && i < bytes.length - 1) {
      output += ' ';
    }

    // Add newline at end of row or end of array
    if ((i + 1) % bytesPerRow === 0 || i === bytes.length - 1) {
      output += '\n';
    }
  }

  return output;
}

/**
 * Generate header file with declarations
 * @param frames Array of frames
 * @param symbolName Sanitized symbol name
 * @param options Export options
 * @returns Header file content
 */
function generateHeaderFile(
  frames: PackedFrame[],
  symbolName: string,
  options: CExportOptions = {}
): string {
  const opts: Required<CExportOptions> = {
    perFrame: options.perFrame ?? false,
    bytesPerRow: options.bytesPerRow ?? 16,
    includeMetadata: options.includeMetadata ?? true,
  };

  let header = '';

  // Header guard
  const guardName = `${symbolName.toUpperCase()}_H`;
  header += `#ifndef ${guardName}\n`;
  header += `#define ${guardName}\n\n`;

  header += `#include <stdint.h>\n\n`;

  if (opts.includeMetadata) {
    header += generateFileHeader(frames, symbolName);
  }

  // Generate declarations
  if (opts.perFrame && frames.length > 1) {
    // Per-frame declarations
    for (let i = 0; i < frames.length; i++) {
      const frameSymbol = `${symbolName}_frame_${i}`;
      header += `extern const uint8_t ${frameSymbol}[${frames[i]!.bytes.length}];\n`;
    }
    header += `\n`;
    header += `extern const uint8_t* const ${symbolName}_frames[${frames.length}];\n`;
    header += `extern const uint16_t ${symbolName}_sizes[${frames.length}];\n`;

    const hasDelays = frames.some(f => f.delayMs !== undefined);
    if (hasDelays) {
      header += `extern const uint16_t ${symbolName}_delays[${frames.length}];\n`;
    }
  } else {
    // Batch mode declarations
    const totalSize = frames.reduce(
      (sum, frame) => sum + frame.bytes.length,
      0
    );
    header += `extern const uint8_t ${symbolName}[${totalSize}];\n`;

    if (frames.length > 1) {
      header += `extern const uint16_t ${symbolName}_offsets[${frames.length}];\n`;
      header += `extern const uint16_t ${symbolName}_sizes[${frames.length}];\n`;
    }
  }

  // Add metadata constants
  if (opts.includeMetadata) {
    const firstFrame = frames[0]!; // Safe because we validate frames.length > 0 earlier
    header += `\n// Metadata constants\n`;
    header += `#define ${symbolName.toUpperCase()}_WIDTH ${firstFrame.dims.width}\n`;
    header += `#define ${symbolName.toUpperCase()}_HEIGHT ${firstFrame.dims.height}\n`;
    header += `#define ${symbolName.toUpperCase()}_FRAMES ${frames.length}\n`;

    if (frames.length > 1) {
      header += `#define ${symbolName.toUpperCase()}_IS_ANIMATION 1\n`;
    } else {
      header += `#define ${symbolName.toUpperCase()}_IS_ANIMATION 0\n`;
    }
  }

  header += `\n#endif // ${guardName}\n`;

  return header;
}

/**
 * Validate C export options
 * @param options Options to validate
 * @returns True if options are valid
 */
export function validateCExportOptions(options: CExportOptions): boolean {
  if (options.bytesPerRow !== undefined) {
    if (options.bytesPerRow < 1 || options.bytesPerRow > 32) {
      return false;
    }
  }

  return true;
}
